// :::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::                                               :::
// :::     Source file for Detector Construction     :::
// :::                                               :::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::

// Include user-made and needed libraries
#include "DetectorConstruction.hh"
#include "CADMesh.hh"               // To import CAD files


// ::::::::::::::::::::::::::::::::
// :::  Constructor definition  :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::
// :::  Destructor definition   :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::~DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::::
// ::: Physical volume definition :::
// :::        (function)          :::
// ::::::::::::::::::::::::::::::::::

G4VPhysicalVolume *DetectorConstruction::Construct()
{ 
    G4bool checkOverlaps = true;                                 // Command to check for geometries overlaps

    G4NistManager  *nist = G4NistManager::Instance();             // Nist manager includes several materials that we can use


    // ::::::::::::::::::::::::::::::::
    // :::          Elements        :::
    // ::::::::::::::::::::::::::::::::
    G4Element*  Lu = nist->FindOrBuildElement("Lu");
    G4Element*  Y  = nist->FindOrBuildElement("Y");
    G4Element*  Si = nist->FindOrBuildElement("Si");
    G4Element*  O  = nist->FindOrBuildElement("O");
    G4Element*  Ce = nist->FindOrBuildElement("Ce");
    G4Element*  Fe = nist->FindOrBuildElement("Fe");
    G4Element*  Cr = nist->FindOrBuildElement("Cr");
    G4Element*  N  = nist->FindOrBuildElement("N");
    G4Element*  Ni = nist->FindOrBuildElement("Ni");
    G4Element*  Mn = nist->FindOrBuildElement("Mn");
    G4Element*  C  = nist->FindOrBuildElement("C");
    G4Element*  S  = nist->FindOrBuildElement("S");
    G4Element*  P  = nist->FindOrBuildElement("P");
    G4Element*  Cu = nist->FindOrBuildElement("Cu");
    G4Element*  Mo = nist->FindOrBuildElement("Mo");
    G4Element*  H = nist->FindOrBuildElement("H");
    

    // ::::::::::::::::::::::::::::::::
    // :::        Materials         :::
    // ::::::::::::::::::::::::::::::::
    G4Material *WorldMat = nist->FindOrBuildMaterial("G4_AIR");   // We name and define a material from the nist manager. For other materials refer to the Geant4 Material Database
    G4Material    *PbMat = nist->FindOrBuildMaterial("G4_Pb");  
    G4Material   *SrcMat = nist->FindOrBuildMaterial("G4_Am");    // Source's material
    G4Material   *DetMat = nist->FindOrBuildMaterial("G4_BGO");  // Detector's Active Volume material
    G4Material   *Water = nist->FindOrBuildMaterial("G4_WATER");  // Detector's Active Volume material


    // ::::::::::::::::::::::::::::::::::::::::::
    // :::  User-defined materials/compounds  :::
    // ::::::::::::::::::::::::::::::::::::::::::

    // To define a new material use the following commands:
    //          G4Material("Name", Density*g/cm3, No. of elements)
    //          Name->AddElement(Element, No of atoms);  // Define the number of elements and the atom numbers for each element

    // :::::::::::::::::::::::::::
    // :::  Examples provided  :::
    // :::::::::::::::::::::::::::

    // :::::::: LYSO ::::::::
    G4Material* LYSO = new G4Material("LYSO", 7.1*g/cm3, 5);
    LYSO->AddElement(Lu, 2);
    LYSO->AddElement( Y, 2);
    LYSO->AddElement(Si, 1);
    LYSO->AddElement( O, 5);
    LYSO->AddElement(Ce, 1);

    // :::::::: Stainless steel 316LVM ::::::::
    // Values retrieved from: https://www.ulbrich.com/alloys/316lvm-stainless-steel-uns-s31673/
    // You can also define a material defining the % of each element. The % must add up 1
    G4Material* StainlessSteel = new G4Material( "SSteel_316LVM", 7.92*g/cm3, 11 );
    StainlessSteel->AddElement( C , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( P , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( Si, 0.0075 ); // 0.75%
    StainlessSteel->AddElement( Ni, 0.13   ); // 13.0%
    StainlessSteel->AddElement( Cu, 0.0005 ); // 0.05%
    StainlessSteel->AddElement( Mn, 0.02   ); // 2.00%
    StainlessSteel->AddElement( S,  0.0001 ); // 0.01%
    StainlessSteel->AddElement( Cr, 0.17   ); // 17.0%
    StainlessSteel->AddElement( Mo, 0.0225 ); // 2.25%
    StainlessSteel->AddElement( N , 0.0010 ); // 0.10%
    StainlessSteel->AddElement( Fe, 0.6478 ); // Balance (64.78%)

    // :::::::: Pebax C2H40 ::::::::
    G4Material* pebax = new G4Material( "Pebax", 1.01*g/cm3, 3 );
    pebax->AddElement( C , 2 );
    pebax->AddElement( H , 4 );
    pebax->AddElement( O , 1 );

    // :::::::: Silicone ::::::::
    G4Material* silicone = new G4Material( "silicone", 1.1*g/cm3, 4 );
    silicone->AddElement( C , 2 );
    silicone->AddElement( H , 6 );
    silicone->AddElement( Si, 1 );
    silicone->AddElement( O , 1 );

    // :::::::: Silicone Grease ::::::::
    G4Material* OpticalGreaseMat = new G4Material( "OpticalGreaseMat", 1.1*g/cm3, 4 );
    OpticalGreaseMat->AddElement( C , 2 );
    OpticalGreaseMat->AddElement( H , 6 );
    OpticalGreaseMat->AddElement( Si, 1 );
    OpticalGreaseMat->AddElement( O , 1 );

    // :::::::: Polyether Ether Ketona (PEEK,C19H12O3) ::::::::
    G4Material* PEEK = new G4Material( "PEEK", 1.32*g/cm3, 3 );
    PEEK->AddElement( C , 19 );
    PEEK->AddElement( H , 12 );
    PEEK->AddElement( O , 3  );


    // ::::::::::::::::::::::::::::::::
    // :::         Geometry         :::
    // ::::::::::::::::::::::::::::::::
    
    // :::  Positions  :::
    Pos1 = G4ThreeVector(0, 0, 0);       // World position
    Pos2 = G4ThreeVector(0*mm, 0*mm, 0*mm);  // Source
    Pos3 = G4ThreeVector(0*mm, 0*mm, 7*mm);  // Detector


    // :::::::::::::::::::
    // :::::: World ::::::
    // :::::::::::::::::::

    // ::: Dimensions :::
    G4double WorldX = 2./2*m; // Geant4 always takes half of the length. Therefore define them as X/2 or X*0.5
    G4double WorldY = 2./2*m;
    G4double WorldZ = 2./2*m;

    World      = new G4Box("World", WorldX, WorldY, WorldZ); // Solids deals with the definition of the shapes
    World_log  = new G4LogicalVolume(World, WorldMat, "World_log");
    World_phys = new G4PVPlacement(0, Pos1, World_log, "World_phys", 0, false, 0, checkOverlaps); // The first 0 means rotation. The world does not need to be rotated so, = 0. 
                                                                                                  // The second 0 means if this volume is a daughter (aka. if it is inside another volume). In this case, No.
                                                                                                  // The third 0 means the copy number.

    // ::::::::::::::::::::::
    // ::::::  Source  ::::::
    // ::::::::::::::::::::::

    Rotation = new G4RotationMatrix();    // A rotation is defined to align all the source geometry in the Y axis direction
    Rotation->rotateX(90.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    G4double SourceInRad     = 0*mm;
    G4double SourceOutRad    = 0.7*mm;
    G4double SourceThickness = 10/2.*mm;

    G4Tubs   *Source  = new G4Tubs("Source", SourceInRad, SourceOutRad, SourceThickness, 0.*deg, 360*deg);
          Source_log  = new G4LogicalVolume(Source, SrcMat, "Source_log");
          Source_phys = new G4PVPlacement(Rotation, Pos2, Source_log, "Source_phys", World_log, 0, checkOverlaps);
            
    
    // ::::::::::::::::::::::
    // :::::: Detector ::::::
    // ::::::::::::::::::::::

    G4double DetectorX = 10/2.*mm;
    G4double DetectorY = 10/2.*mm;
    G4double DetectorZ = 10/2.*mm;

    Detector      = new G4Box("Detector", DetectorX, DetectorY, DetectorZ);
    Detector_log  = new G4LogicalVolume(Detector, DetMat, "Detector_log");
    Detector_phys = new G4PVPlacement(0, Pos3, Detector_log, "Detector_phys", World_log, false, checkOverlaps);
            
        
    // ::::::::::::::::::::::::::::::::::::::
    // :::          CAD Geometries        :::
    // ::::::::::::::::::::::::::::::::::::::

    /* In this section you can add more geometries using CAD files in .obj or .stl format.
     * !!! Coppy and uncomment the following section if you want to model the CAD files, or if you wich to add more CAD geometries. !!!
     * !!! The 'X' represents the number of CAD geometries, 'Name' is the name of the CAD file, and 'MATERIAL' should be defined before compiling. !!!
     *
     * The CAD files are added throught the GUI, but if you wish to add them manually, here is the detailed processs on how to proceed:
     *     1) Import .obj, or .stl geometry using:
     *
     *        auto meshX = CADMesh::TessellatedMesh::FromOBJ("NAME.obj");  // If you want to add more CAD files, keep using mesh2,3,4, etc. Remember to write the correct file name!
     *        auto meshx = CADMesh::TessellatedMesh::FromSTL("Name.stl");  // stl geometries MUST BE SAVED IN ASCII STL
     *
     *     2) Scale the geoemtry. Recommended to set it to 1 to keep your original dimensions
     *
     *        meshX->SetScale(1); // For more geoemtries use mesh2, mesh3, etc.
     *
     *     3) Setting an offset in the geoemtry position. Modify it as needed, but adding mesh2, mesh3, etc for more geometries.
     *
     *        meshX->SetOffset(x, y, z);
     *        meshX->SetOffset(G4ThreeVector(x, y, z));
     *
     *     4) Assigning names and materials. Replace NAME for the name of your geometry (e.g.  NAME --> Shielding).
     *                                       Replace MATERIAL with your defined material (e.g. MATERIAL --> LYSO).
     *
     *        // ::: Name :::
     *        auto NAME     = meshX->GetSolid();                                      
     *        auto NAME_log = new G4LogicalVolume(NAME, MATERIAL, "NAME_log",0,0,0);
     *                        new G4PVPlacement(rotation, Pos1, "NAME", NAME_log, World_log, false, 0, false);
     * 
     * Credits to Christopher Poole for this section (https://github.com/christopherpoole/CADMesh/tree/master)
     */

    G4double x = 0.0; // Do not comment this line.
    G4double y = 0.0; // Do not comment this line.
    G4double z = 0.0; // Do not comment this line.
    
    /*  // :::::::::::: UNCOMMENT THE FOLLOWING SECTION STARTING FROM HERE UP TO ....
     *  //std::string basePath = "/Obj/";  // For .obj files
     *  //std::string basePath = "/Stl/";  // For .stl files. MUST BE IN ASCII STL

       

    */  // ... UP TO HERE! 


    // ::::::::::::::::::::::::::::::::::::::
    // :::    Visualisation Attributes    :::
    // ::::::::::::::::::::::::::::::::::::::

    // Add your CAD_log volumes here for visualization too

    // ::: Detector :::
    G4VisAttributes *DetVisAtt = new G4VisAttributes(G4Color(0.0, 0.0, 1.0, 0.5)); // Blue
    DetVisAtt->SetForceSolid(true);
    Detector_log->SetVisAttributes(DetVisAtt);

    // ::: Source :::
    G4VisAttributes *SrcVisAtt = new G4VisAttributes(G4Color(1.0, 0.0, 0.0, 0.5)); // Red
    SrcVisAtt->SetForceSolid(true);
    Source_log->SetVisAttributes(SrcVisAtt);


    return World_phys;  // Always return the physical World
}


// ::::::::::::::::::::::::::::::::::
// :::    Sensitive Detector      :::
// :::         function           :::
// ::::::::::::::::::::::::::::::::::

void DetectorConstruction::ConstructSDandField()
{
    SensitiveDetector *sensDet = new SensitiveDetector("SensitiveDetector");
    Detector_log->SetSensitiveDetector(sensDet);
    G4SDManager::GetSDMpointer()->AddNewDetector(sensDet);
}

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::: End ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        