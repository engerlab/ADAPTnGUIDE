// :::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::                                               :::
// :::     Source file for Detector Construction     :::
// :::                                               :::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::

// Include user-made and needed libraries
#include "DetectorConstruction.hh"
#include "CADMesh.hh"               // To import CAD files


// ::::::::::::::::::::::::::::::::
// :::  Constructor definition  :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::
// :::  Destructor definition   :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::~DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::::
// ::: Physical volume definition :::
// :::        (function)          :::
// ::::::::::::::::::::::::::::::::::

G4VPhysicalVolume *DetectorConstruction::Construct()
{ 
    G4bool checkOverlaps = true;                                 // Command to check for geometries overlaps

    G4NistManager  *nist = G4NistManager::Instance();             // Nist manager includes several materials that we can use


    // ::::::::::::::::::::::::::::::::
    // :::          Elements        :::
    // ::::::::::::::::::::::::::::::::
    G4Element*  Lu = nist->FindOrBuildElement("Lu");
    G4Element*  Y  = nist->FindOrBuildElement("Y");
    G4Element*  Si = nist->FindOrBuildElement("Si");
    G4Element*  O  = nist->FindOrBuildElement("O");
    G4Element*  Ce = nist->FindOrBuildElement("Ce");
    G4Element*  Fe = nist->FindOrBuildElement("Fe");
    G4Element*  Cr = nist->FindOrBuildElement("Cr");
    G4Element*  N  = nist->FindOrBuildElement("N");
    G4Element*  Ni = nist->FindOrBuildElement("Ni");
    G4Element*  Mn = nist->FindOrBuildElement("Mn");
    G4Element*  C  = nist->FindOrBuildElement("C");
    G4Element*  S  = nist->FindOrBuildElement("S");
    G4Element*  P  = nist->FindOrBuildElement("P");
    G4Element*  Cu = nist->FindOrBuildElement("Cu");
    G4Element*  Mo = nist->FindOrBuildElement("Mo");
    G4Element*  H = nist->FindOrBuildElement("H");
    

    // ::::::::::::::::::::::::::::::::
    // :::        Materials         :::
    // ::::::::::::::::::::::::::::::::
    G4Material *WorldMat = nist->FindOrBuildMaterial("G4_AIR");   // We name and define a material from the nist manager. For other materials refer to the Geant4 Material Database
    G4Material    *PbMat = nist->FindOrBuildMaterial("G4_Pb");  
    G4Material   *SrcMat = nist->FindOrBuildMaterial("G4_Li");    // Source's material
    G4Material   *DetMat = nist->FindOrBuildMaterial("G4_He");  // Detector's Active Volume material
    G4Material   *Water = nist->FindOrBuildMaterial("G4_WATER");  // Detector's Active Volume material


    // ::::::::::::::::::::::::::::::::::::::::::
    // :::  User-defined materials/compounds  :::
    // ::::::::::::::::::::::::::::::::::::::::::

    // To define a new material use the following commands:
    //          G4Material("Name", Density*g/cm3, No. of elements)
    //          Name->AddElement(Element, No of atoms);  // Define the number of elements and the atom numbers for each element

    // :::::::::::::::::::::::::::
    // :::  Examples provided  :::
    // :::::::::::::::::::::::::::

    // :::::::: LYSO ::::::::
    G4Material* LYSO = new G4Material("LYSO", 7.1*g/cm3, 5);
    LYSO->AddElement(Lu, 2);
    LYSO->AddElement( Y, 2);
    LYSO->AddElement(Si, 1);
    LYSO->AddElement( O, 5);
    LYSO->AddElement(Ce, 1);

    // :::::::: Stainless steel 316LVM ::::::::
    // Values retrieved from: https://www.ulbrich.com/alloys/316lvm-stainless-steel-uns-s31673/
    // You can also define a material defining the % of each element. The % must add up 1
    G4Material* StainlessSteel = new G4Material( "SSteel_316LVM", 7.92*g/cm3, 11 );
    StainlessSteel->AddElement( C , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( P , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( Si, 0.0075 ); // 0.75%
    StainlessSteel->AddElement( Ni, 0.13   ); // 13.0%
    StainlessSteel->AddElement( Cu, 0.0005 ); // 0.05%
    StainlessSteel->AddElement( Mn, 0.02   ); // 2.00%
    StainlessSteel->AddElement( S,  0.0001 ); // 0.01%
    StainlessSteel->AddElement( Cr, 0.17   ); // 17.0%
    StainlessSteel->AddElement( Mo, 0.0225 ); // 2.25%
    StainlessSteel->AddElement( N , 0.0010 ); // 0.10%
    StainlessSteel->AddElement( Fe, 0.6478 ); // Balance (64.78%)

    // :::::::: Pebax C2H40 ::::::::
    G4Material* pebax = new G4Material( "Pebax", 1.01*g/cm3, 3 );
    pebax->AddElement( C , 2 );
    pebax->AddElement( H , 4 );
    pebax->AddElement( O , 1 );

    // :::::::: Silicone ::::::::
    G4Material* silicone = new G4Material( "silicone", 1.1*g/cm3, 4 );
    silicone->AddElement( C , 2 );
    silicone->AddElement( H , 6 );
    silicone->AddElement( Si, 1 );
    silicone->AddElement( O , 1 );

    // :::::::: Silicone Grease ::::::::
    G4Material* OpticalGreaseMat = new G4Material( "OpticalGreaseMat", 1.1*g/cm3, 4 );
    OpticalGreaseMat->AddElement( C , 2 );
    OpticalGreaseMat->AddElement( H , 6 );
    OpticalGreaseMat->AddElement( Si, 1 );
    OpticalGreaseMat->AddElement( O , 1 );

    // :::::::: Polyether Ether Ketona (PEEK,C19H12O3) ::::::::
    G4Material* PEEK = new G4Material( "PEEK", 1.32*g/cm3, 3 );
    PEEK->AddElement( C , 19 );
    PEEK->AddElement( H , 12 );
    PEEK->AddElement( O , 3  );


    // ::::::::::::::::::::::::::::::::
    // :::         Geometry         :::
    // ::::::::::::::::::::::::::::::::
    
    // :::  Positions  :::
    Pos1 = G4ThreeVector(0, 0, 0);       // World position
    Pos2 = G4ThreeVector(0*mm, 0*mm, 0*mm);  // Source
    Pos3 = G4ThreeVector(0*mm, 0*mm, 0*mm);  // Detector


    // :::::::::::::::::::
    // :::::: World ::::::
    // :::::::::::::::::::

    // ::: Dimensions :::
    G4double WorldX = 2./2*m; // Geant4 always takes half of the length. Therefore define them as X/2 or X*0.5
    G4double WorldY = 2./2*m;
    G4double WorldZ = 2./2*m;

    World      = new G4Box("World", WorldX, WorldY, WorldZ); // Solids deals with the definition of the shapes
    World_log  = new G4LogicalVolume(World, WorldMat, "World_log");
    World_phys = new G4PVPlacement(0, Pos1, World_log, "World_phys", 0, false, 0, checkOverlaps); // The first 0 means rotation. The world does not need to be rotated so, = 0. 
                                                                                                  // The second 0 means if this volume is a daughter (aka. if it is inside another volume). In this case, No.
                                                                                                  // The third 0 means the copy number.

    // ::::::::::::::::::::::
    // ::::::  Source  ::::::
    // ::::::::::::::::::::::

    Rotation = new G4RotationMatrix();    // A rotation is defined to align all the source geometry in the Y axis direction
    Rotation->rotateX(90.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    G4double SourceInRad     = 0.2*mm;
    G4double SourceOutRad    = 0.35*mm;
    G4double SourceThickness = 5/2.*mm;

    G4Tubs   *Source  = new G4Tubs("Source", SourceInRad, SourceOutRad, SourceThickness, 0.*deg, 360*deg);
          Source_log  = new G4LogicalVolume(Source, SrcMat, "Source_log");
          Source_phys = new G4PVPlacement(Rotation, Pos2, Source_log, "Source_phys", World_log, 0, checkOverlaps);
            
    
    // ::::::::::::::::::::::
    // :::::: Detector ::::::
    // ::::::::::::::::::::::

    G4double DetectorX = 10/2.*mm;
    G4double DetectorY = 10/2.*mm;
    G4double DetectorZ = 10/2.*mm;

    Detector      = new G4Box("Detector", DetectorX, DetectorY, DetectorZ);
    Detector_log  = new G4LogicalVolume(Detector, DetMat, "Detector_log");
    Detector_phys = new G4PVPlacement(0, Pos3, Detector_log, "Detector_phys", World_log, false, checkOverlaps);
            
        
    // ::::::::::::::::::::::::::::::::::::::
    // :::          CAD Geometries        :::
    // ::::::::::::::::::::::::::::::::::::::

    /* In this section you can add more geometries using CAD files in .obj or .stl format.
     * !!! Coppy and uncomment the following section if you want to model the CAD files, or if you wich to add more CAD geometries. !!!
     * !!! The 'X' represents the number of CAD geometries, 'Name' is the name of the CAD file, and 'MATERIAL' should be defined before compiling. !!!
     *
     * The CAD files are added throught the GUI, but if you wish to add them manually, here is the detailed processs on how to proceed:
     *     1) Import .obj, or .stl geometry using:
     *
     *        auto meshX = CADMesh::TessellatedMesh::FromOBJ("NAME.obj");  // If you want to add more CAD files, keep using mesh2,3,4, etc. Remember to write the correct file name!
     *        auto meshx = CADMesh::TessellatedMesh::FromSTL("Name.stl");  // stl geometries MUST BE SAVED IN ASCII STL
     *
     *     2) Scale the geoemtry. Recommended to set it to 1 to keep your original dimensions
     *
     *        meshX->SetScale(1); // For more geoemtries use mesh2, mesh3, etc.
     *
     *     3) Setting an offset in the geoemtry position. Modify it as needed, but adding mesh2, mesh3, etc for more geometries.
     *
     *        meshX->SetOffset(x, y, z);
     *        meshX->SetOffset(G4ThreeVector(x, y, z));
     *
     *     4) Assigning names and materials. Replace NAME for the name of your geometry (e.g.  NAME --> Shielding).
     *                                       Replace MATERIAL with your defined material (e.g. MATERIAL --> LYSO).
     *
     *        // ::: Name :::
     *        auto NAME     = meshX->GetSolid();                                      
     *        auto NAME_log = new G4LogicalVolume(NAME, MATERIAL, "NAME_log",0,0,0);
     *                        new G4PVPlacement(rotation, Pos1, "NAME", NAME_log, World_log, false, 0, false);
     * 
     * Credits to Christopher Poole for this section (https://github.com/christopherpoole/CADMesh/tree/master)
     */

    G4double x = 0.0; // Do not comment this line.
    G4double y = 0.0; // Do not comment this line.
    G4double z = 0.0; // Do not comment this line.
    
    /*  // :::::::::::: UNCOMMENT THE FOLLOWING SECTION STARTING FROM HERE UP TO ....
     *  //std::string basePath = "/Users/victor/Desktop/Gate/ADAPT/CAD_Files/Stl/Obj/";  // For .obj files
     *  //std::string basePath = "/Users/victor/Desktop/Gate/ADAPT/CAD_Files/Stl/Stl/";  // For .stl files. MUST BE IN ASCII STL

       
    // ::: ApplicatorBody :::
    //auto mesh1 = CADMesh::TessellatedMesh::FromOBJ(basePath + "ApplicatorBody.obj");
    //auto mesh1 = CADMesh::TessellatedMesh::FromSTL(basePath + "ApplicatorBody.stl");

    //mesh1->SetScale(1);
    //mesh1->SetOffset(x, y, z);
    //mesh1->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto ApplicatorBody = mesh1->GetSolid();
    //auto ApplicatorBody_log = new G4LogicalVolume(ApplicatorBody, MATERIAL, "ApplicatorBody_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, ApplicatorBody_log, "ApplicatorBody", World_log, 0, checkOverlaps); // ...here.
            
    // ::: ApplicatorScrew :::
    //auto mesh2 = CADMesh::TessellatedMesh::FromOBJ(basePath + "ApplicatorScrew.obj");
    //auto mesh2 = CADMesh::TessellatedMesh::FromSTL(basePath + "ApplicatorScrew.stl");

    //mesh2->SetScale(1);
    //mesh2->SetOffset(x, y, z);
    //mesh2->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto ApplicatorScrew = mesh2->GetSolid();
    //auto ApplicatorScrew_log = new G4LogicalVolume(ApplicatorScrew, MATERIAL, "ApplicatorScrew_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, ApplicatorScrew_log, "ApplicatorScrew", World_log, 0, checkOverlaps); // ...here.
            
    // ::: BottomHolder :::
    //auto mesh3 = CADMesh::TessellatedMesh::FromOBJ(basePath + "BottomHolder.obj");
    //auto mesh3 = CADMesh::TessellatedMesh::FromSTL(basePath + "BottomHolder.stl");

    //mesh3->SetScale(1);
    //mesh3->SetOffset(x, y, z);
    //mesh3->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto BottomHolder = mesh3->GetSolid();
    //auto BottomHolder_log = new G4LogicalVolume(BottomHolder, MATERIAL, "BottomHolder_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, BottomHolder_log, "BottomHolder", World_log, 0, checkOverlaps); // ...here.
            
    // ::: BottomShield :::
    //auto mesh4 = CADMesh::TessellatedMesh::FromOBJ(basePath + "BottomShield.obj");
    //auto mesh4 = CADMesh::TessellatedMesh::FromSTL(basePath + "BottomShield.stl");

    //mesh4->SetScale(1);
    //mesh4->SetOffset(x, y, z);
    //mesh4->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto BottomShield = mesh4->GetSolid();
    //auto BottomShield_log = new G4LogicalVolume(BottomShield, MATERIAL, "BottomShield_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, BottomShield_log, "BottomShield", World_log, 0, checkOverlaps); // ...here.
            
    // ::: Glycerine :::
    //auto mesh5 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Glycerine.obj");
    //auto mesh5 = CADMesh::TessellatedMesh::FromSTL(basePath + "Glycerine.stl");

    //mesh5->SetScale(1);
    //mesh5->SetOffset(x, y, z);
    //mesh5->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto Glycerine = mesh5->GetSolid();
    //auto Glycerine_log = new G4LogicalVolume(Glycerine, MATERIAL, "Glycerine_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, Glycerine_log, "Glycerine", World_log, 0, checkOverlaps); // ...here.
            
    // ::: LYSOHex :::
    //auto mesh6 = CADMesh::TessellatedMesh::FromOBJ(basePath + "LYSOHex.obj");
    //auto mesh6 = CADMesh::TessellatedMesh::FromSTL(basePath + "LYSOHex.stl");

    //mesh6->SetScale(1);
    //mesh6->SetOffset(x, y, z);
    //mesh6->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto LYSOHex = mesh6->GetSolid();
    //auto LYSOHex_log = new G4LogicalVolume(LYSOHex, MATERIAL, "LYSOHex_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, LYSOHex_log, "LYSOHex", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease1 :::
    //auto mesh7 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease1.obj");
    //auto mesh7 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease1.stl");

    //mesh7->SetScale(1);
    //mesh7->SetOffset(x, y, z);
    //mesh7->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease1 = mesh7->GetSolid();
    //auto OpticalGrease1_log = new G4LogicalVolume(OpticalGrease1, MATERIAL, "OpticalGrease1_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease1_log, "OpticalGrease1", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease2 :::
    //auto mesh8 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease2.obj");
    //auto mesh8 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease2.stl");

    //mesh8->SetScale(1);
    //mesh8->SetOffset(x, y, z);
    //mesh8->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease2 = mesh8->GetSolid();
    //auto OpticalGrease2_log = new G4LogicalVolume(OpticalGrease2, MATERIAL, "OpticalGrease2_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease2_log, "OpticalGrease2", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease3 :::
    //auto mesh9 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease3.obj");
    //auto mesh9 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease3.stl");

    //mesh9->SetScale(1);
    //mesh9->SetOffset(x, y, z);
    //mesh9->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease3 = mesh9->GetSolid();
    //auto OpticalGrease3_log = new G4LogicalVolume(OpticalGrease3, MATERIAL, "OpticalGrease3_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease3_log, "OpticalGrease3", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease4 :::
    //auto mesh10 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease4.obj");
    //auto mesh10 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease4.stl");

    //mesh10->SetScale(1);
    //mesh10->SetOffset(x, y, z);
    //mesh10->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease4 = mesh10->GetSolid();
    //auto OpticalGrease4_log = new G4LogicalVolume(OpticalGrease4, MATERIAL, "OpticalGrease4_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease4_log, "OpticalGrease4", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease5 :::
    //auto mesh11 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease5.obj");
    //auto mesh11 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease5.stl");

    //mesh11->SetScale(1);
    //mesh11->SetOffset(x, y, z);
    //mesh11->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease5 = mesh11->GetSolid();
    //auto OpticalGrease5_log = new G4LogicalVolume(OpticalGrease5, MATERIAL, "OpticalGrease5_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease5_log, "OpticalGrease5", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OpticalGrease6 :::
    //auto mesh12 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OpticalGrease6.obj");
    //auto mesh12 = CADMesh::TessellatedMesh::FromSTL(basePath + "OpticalGrease6.stl");

    //mesh12->SetScale(1);
    //mesh12->SetOffset(x, y, z);
    //mesh12->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto OpticalGrease6 = mesh12->GetSolid();
    //auto OpticalGrease6_log = new G4LogicalVolume(OpticalGrease6, MATERIAL, "OpticalGrease6_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, OpticalGrease6_log, "OpticalGrease6", World_log, 0, checkOverlaps); // ...here.
            
    // ::: Pebax :::
    //auto mesh13 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Pebax.obj");
    //auto mesh13 = CADMesh::TessellatedMesh::FromSTL(basePath + "Pebax.stl");

    //mesh13->SetScale(1);
    //mesh13->SetOffset(x, y, z);
    //mesh13->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto Pebax = mesh13->GetSolid();
    //auto Pebax_log = new G4LogicalVolume(Pebax, MATERIAL, "Pebax_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, Pebax_log, "Pebax", World_log, 0, checkOverlaps); // ...here.
            
    // ::: Pusher :::
    //auto mesh14 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Pusher.obj");
    //auto mesh14 = CADMesh::TessellatedMesh::FromSTL(basePath + "Pusher.stl");

    //mesh14->SetScale(1);
    //mesh14->SetOffset(x, y, z);
    //mesh14->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto Pusher = mesh14->GetSolid();
    //auto Pusher_log = new G4LogicalVolume(Pusher, MATERIAL, "Pusher_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, Pusher_log, "Pusher", World_log, 0, checkOverlaps); // ...here.
            
    // ::: Seringe :::
    //auto mesh15 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Seringe.obj");
    //auto mesh15 = CADMesh::TessellatedMesh::FromSTL(basePath + "Seringe.stl");

    //mesh15->SetScale(1);
    //mesh15->SetOffset(x, y, z);
    //mesh15->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto Seringe = mesh15->GetSolid();
    //auto Seringe_log = new G4LogicalVolume(Seringe, MATERIAL, "Seringe_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, Seringe_log, "Seringe", World_log, 0, checkOverlaps); // ...here.
            
    // ::: Silicone :::
    //auto mesh16 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Silicone.obj");
    //auto mesh16 = CADMesh::TessellatedMesh::FromSTL(basePath + "Silicone.stl");

    //mesh16->SetScale(1);
    //mesh16->SetOffset(x, y, z);
    //mesh16->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto Silicone = mesh16->GetSolid();
    //auto Silicone_log = new G4LogicalVolume(Silicone, MATERIAL, "Silicone_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, Silicone_log, "Silicone", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM1 :::
    //auto mesh17 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM1.obj");
    //auto mesh17 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM1.stl");

    //mesh17->SetScale(1);
    //mesh17->SetOffset(x, y, z);
    //mesh17->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM1 = mesh17->GetSolid();
    //auto SiPM1_log = new G4LogicalVolume(SiPM1, MATERIAL, "SiPM1_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM1_log, "SiPM1", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM2 :::
    //auto mesh18 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM2.obj");
    //auto mesh18 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM2.stl");

    //mesh18->SetScale(1);
    //mesh18->SetOffset(x, y, z);
    //mesh18->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM2 = mesh18->GetSolid();
    //auto SiPM2_log = new G4LogicalVolume(SiPM2, MATERIAL, "SiPM2_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM2_log, "SiPM2", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM3 :::
    //auto mesh19 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM3.obj");
    //auto mesh19 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM3.stl");

    //mesh19->SetScale(1);
    //mesh19->SetOffset(x, y, z);
    //mesh19->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM3 = mesh19->GetSolid();
    //auto SiPM3_log = new G4LogicalVolume(SiPM3, MATERIAL, "SiPM3_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM3_log, "SiPM3", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM4 :::
    //auto mesh20 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM4.obj");
    //auto mesh20 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM4.stl");

    //mesh20->SetScale(1);
    //mesh20->SetOffset(x, y, z);
    //mesh20->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM4 = mesh20->GetSolid();
    //auto SiPM4_log = new G4LogicalVolume(SiPM4, MATERIAL, "SiPM4_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM4_log, "SiPM4", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM5 :::
    //auto mesh21 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM5.obj");
    //auto mesh21 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM5.stl");

    //mesh21->SetScale(1);
    //mesh21->SetOffset(x, y, z);
    //mesh21->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM5 = mesh21->GetSolid();
    //auto SiPM5_log = new G4LogicalVolume(SiPM5, MATERIAL, "SiPM5_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM5_log, "SiPM5", World_log, 0, checkOverlaps); // ...here.
            
    // ::: SiPM6 :::
    //auto mesh22 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SiPM6.obj");
    //auto mesh22 = CADMesh::TessellatedMesh::FromSTL(basePath + "SiPM6.stl");

    //mesh22->SetScale(1);
    //mesh22->SetOffset(x, y, z);
    //mesh22->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto SiPM6 = mesh22->GetSolid();
    //auto SiPM6_log = new G4LogicalVolume(SiPM6, MATERIAL, "SiPM6_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, SiPM6_log, "SiPM6", World_log, 0, checkOverlaps); // ...here.
            
    // ::: TopHolder :::
    //auto mesh23 = CADMesh::TessellatedMesh::FromOBJ(basePath + "TopHolder.obj");
    //auto mesh23 = CADMesh::TessellatedMesh::FromSTL(basePath + "TopHolder.stl");

    //mesh23->SetScale(1);
    //mesh23->SetOffset(x, y, z);
    //mesh23->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto TopHolder = mesh23->GetSolid();
    //auto TopHolder_log = new G4LogicalVolume(TopHolder, MATERIAL, "TopHolder_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, TopHolder_log, "TopHolder", World_log, 0, checkOverlaps); // ...here.
            
    // ::: TopShield :::
    //auto mesh24 = CADMesh::TessellatedMesh::FromOBJ(basePath + "TopShield.obj");
    //auto mesh24 = CADMesh::TessellatedMesh::FromSTL(basePath + "TopShield.stl");

    //mesh24->SetScale(1);
    //mesh24->SetOffset(x, y, z);
    //mesh24->SetOffset(G4ThreeVector(x, y, z));

    //Rotation = new G4RotationMatrix();
    //Rotation->rotateX(0.*deg);
    //Rotation->rotateY(0.*deg);
    //Rotation->rotateZ(0.*deg);

    //auto TopShield = mesh24->GetSolid();
    //auto TopShield_log = new G4LogicalVolume(TopShield, MATERIAL, "TopShield_log", 0, 0, 0);
    //                    new G4PVPlacement(Rotation, Pos1, TopShield_log, "TopShield", World_log, 0, checkOverlaps); // ...here.
            

    */  // ... UP TO HERE! 


    // ::::::::::::::::::::::::::::::::::::::
    // :::    Visualisation Attributes    :::
    // ::::::::::::::::::::::::::::::::::::::

    // Add your CAD_log volumes here for visualization too

    // ::: Detector :::
    G4VisAttributes *DetVisAtt = new G4VisAttributes(G4Color(0.0, 0.0, 1.0, 0.5)); // Blue
    DetVisAtt->SetForceSolid(true);
    Detector_log->SetVisAttributes(DetVisAtt);

    // ::: Source :::
    G4VisAttributes *SrcVisAtt = new G4VisAttributes(G4Color(1.0, 0.0, 0.0, 0.5)); // Red
    SrcVisAtt->SetForceSolid(true);
    Source_log->SetVisAttributes(SrcVisAtt);


    return World_phys;  // Always return the physical World
}


// ::::::::::::::::::::::::::::::::::
// :::    Sensitive Detector      :::
// :::         function           :::
// ::::::::::::::::::::::::::::::::::

void DetectorConstruction::ConstructSDandField()
{
    SensitiveDetector *sensDet = new SensitiveDetector("SensitiveDetector");
    Detector_log->SetSensitiveDetector(sensDet);
    G4SDManager::GetSDMpointer()->AddNewDetector(sensDet);
}

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::: End ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        