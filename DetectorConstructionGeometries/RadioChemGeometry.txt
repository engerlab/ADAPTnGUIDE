// :::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::                                               :::
// :::     Source file for Detector Construction     :::
// :::                                               :::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::

// Include user-made and needed libraries
#include "DetectorConstruction.hh"
#include "CADMesh.hh"               // To import CAD files


// ::::::::::::::::::::::::::::::::
// :::  Constructor definition  :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::
// :::  Destructor definition   :::
// ::::::::::::::::::::::::::::::::

DetectorConstruction::~DetectorConstruction()
{}


// ::::::::::::::::::::::::::::::::::
// ::: Physical volume definition :::
// :::        (function)          :::
// ::::::::::::::::::::::::::::::::::

G4VPhysicalVolume *DetectorConstruction::Construct()
{ 
    G4bool checkOverlaps = true;                                 // Command to check for geometries overlaps

    G4NistManager  *nist = G4NistManager::Instance();             // Nist manager includes several materials that we can use


    // ::::::::::::::::::::::::::::::::
    // :::          Elements        :::
    // ::::::::::::::::::::::::::::::::
    G4Element*  Lu = nist->FindOrBuildElement("Lu");
    G4Element*  Y  = nist->FindOrBuildElement("Y");
    G4Element*  Si = nist->FindOrBuildElement("Si");
    G4Element*  O  = nist->FindOrBuildElement("O");
    G4Element*  Ce = nist->FindOrBuildElement("Ce");
    G4Element*  Fe = nist->FindOrBuildElement("Fe");
    G4Element*  Cr = nist->FindOrBuildElement("Cr");
    G4Element*  N  = nist->FindOrBuildElement("N");
    G4Element*  Ni = nist->FindOrBuildElement("Ni");
    G4Element*  Mn = nist->FindOrBuildElement("Mn");
    G4Element*  C  = nist->FindOrBuildElement("C");
    G4Element*  S  = nist->FindOrBuildElement("S");
    G4Element*  P  = nist->FindOrBuildElement("P");
    G4Element*  Cu = nist->FindOrBuildElement("Cu");
    G4Element*  Mo = nist->FindOrBuildElement("Mo");
    G4Element*  H = nist->FindOrBuildElement("H");
    

    // ::::::::::::::::::::::::::::::::
    // :::        Materials         :::
    // ::::::::::::::::::::::::::::::::
    G4Material *WorldMat = nist->FindOrBuildMaterial("G4_AIR");   // We name and define a material from the nist manager. For other materials refer to the Geant4 Material Database
    G4Material    *PbMat = nist->FindOrBuildMaterial("G4_Pb");  
    G4Material   *SrcMat = nist->FindOrBuildMaterial("G4_WATER");    // Source's material
    G4Material   *DetMat = nist->FindOrBuildMaterial("G4_POLYSTYRENE");  // Detector's Active Volume material
    G4Material   *Water = nist->FindOrBuildMaterial("G4_WATER");  // Detector's Active Volume material
    G4Material   *Glass = nist->FindOrBuildMaterial("G4_Pyrex_Glass");
    G4Material    *PMMA = nist->FindOrBuildMaterial("G4_PLEXIGLASS");
    G4Material     *PVC = nist->FindOrBuildMaterial("G4_POLYETHYLENE");


    // ::::::::::::::::::::::::::::::::::::::::::
    // :::  User-defined materials/compounds  :::
    // ::::::::::::::::::::::::::::::::::::::::::

    // To define a new material use the following command:
    // G4Material("Name", Density*g/CLHEP::cm3, No. of elements)
    // Next use the following command depending on the number of elements.
    // Name->AddElement(Element, No of atoms)

    // :::::::::::::::::::::::::::
    // :::  Examples provided  :::
    // :::::::::::::::::::::::::::

    // :::::::: LYSO ::::::::
    G4Material* LYSO = new G4Material("LYSO", 7.1*g/CLHEP::cm3, 5);
    LYSO->AddElement(Lu, 2);
    LYSO->AddElement(Y, 2);
    LYSO->AddElement(Si, 1);
    LYSO->AddElement( O, 5);
    LYSO->AddElement(Ce, 1);

    // :::::::: Stainless steel 316LVM ::::::::
    // Values retrieved from: https://www.ulbrich.com/alloys/316lvm-stainless-steel-uns-s31673/
    G4Material* StainlessSteel = new G4Material( "SSteel_316LVM", 7.92*g/CLHEP::cm3, 11 );
    StainlessSteel->AddElement( C , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( P , 0.0003 ); // 0.03%
    StainlessSteel->AddElement( Si, 0.0075 ); // 0.75%
    StainlessSteel->AddElement( Ni, 0.13   ); // 13.0%
    StainlessSteel->AddElement( Cu, 0.0005 ); // 0.05%
    StainlessSteel->AddElement( Mn, 0.02   ); // 2.00%
    StainlessSteel->AddElement( S,  0.0001 ); // 0.01%
    StainlessSteel->AddElement( Cr, 0.17   ); // 17.0%
    StainlessSteel->AddElement( Mo, 0.0225 ); // 2.25%
    StainlessSteel->AddElement( N , 0.0010 ); // 0.10%
    StainlessSteel->AddElement( Fe, 0.6478 ); // Balance (64.78%)

     // :::::::: PLA C3H402 ::::::::
    G4Material* PLA = new G4Material( "PLA", 1.21*g/CLHEP::cm3, 3 );
    PLA->AddElement( C , 3 );
    PLA->AddElement( H , 4 );
    PLA->AddElement( O , 2 );

    // :::::::: Pebax C2H40 ::::::::
    G4Material* pebax = new G4Material( "Pebax", 1.01*g/CLHEP::cm3, 3 );
    pebax->AddElement( C , 2 );
    pebax->AddElement( H , 4 );
    pebax->AddElement( O , 1 );

    // :::::::: Silicone ::::::::
    G4Material* silicone = new G4Material( "silicone", 1.1*g/CLHEP::cm3, 4 );
    silicone->AddElement( C , 2 );
    silicone->AddElement( H , 6 );
    silicone->AddElement( Si, 1 );
    silicone->AddElement( O , 1 );

    // :::::::: Silicone Grease ::::::::
    G4Material* OpticalGreaseMat = new G4Material( "OpticalGreaseMat", 1.1*g/CLHEP::cm3, 4 );
    OpticalGreaseMat->AddElement( C , 2 );
    OpticalGreaseMat->AddElement( H , 6 );
    OpticalGreaseMat->AddElement( Si, 1 );
    OpticalGreaseMat->AddElement( O , 1 );

    // :::::::: Polyether Ether Ketona (PEEK,C19H12O3) ::::::::
    G4Material* PEEK = new G4Material( "PEEK", 1.32*g/CLHEP::cm3, 3 );
    PEEK->AddElement( C , 19 );
    PEEK->AddElement( H , 12 );
    PEEK->AddElement( O , 3  );


    // ::::::::::::::::::::::::::::::::
    // :::         Geometry         :::
    // ::::::::::::::::::::::::::::::::
    
    // :::  Positions  :::
    Pos1 = G4ThreeVector(0, 0, 0);       // World position
    Pos2 = G4ThreeVector(0*mm, 0*mm, 0*mm);  // Source
    Pos3 = G4ThreeVector(0*mm, 0*mm, 0*mm);  // Detector

    // :::::::::::::::::::
    // :::::: World ::::::
    // :::::::::::::::::::

    // ::: Dimensions :::
    G4double WorldX = 2./2*m; // Geant4 always take half of the length. Therefore define them as X/2 or X*0.5
    G4double WorldY = 2./2*m;
    G4double WorldZ = 2./2*m;

    World      = new G4Box("World", WorldX, WorldY, WorldZ); // Solids deals with the definition of the shapes
    World_log  = new G4LogicalVolume(World, WorldMat, "World_log");
    World_phys = new G4PVPlacement(0, Pos1, World_log, "World_phys", 0, false, 0, checkOverlaps); // The first 0 means rotation. The world does not need to be rotated so, = 0. 
                                                                                                  // The second 0 means if this volume is a daughter (aka. if it is inside another volume). In this case, No.
                                                                                                  // The third 0 means the copy number.

    // ::::::::::::::::::::::
    // ::::::  Source  ::::::
    // ::::::::::::::::::::::

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(90.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    G4double SourceInRad     = 0*mm;
    G4double SourceOutRad    = 9*mm;
    G4double SourceThickness = 28/2.*mm;

    G4Tubs   *Source  = new G4Tubs("Source", SourceInRad, SourceOutRad, SourceThickness, 0.*deg, 360*deg);
          Source_log  = new G4LogicalVolume(Source, SrcMat, "Source_log");
          Source_phys = new G4PVPlacement(Rotation, Pos2, Source_log, "Source_phys", World_log, 0, checkOverlaps);
            

    // ::::::::::::::::::::::
    // :::::: Detector ::::::
    // ::::::::::::::::::::::
/*
    G4double DetInnerRadius = 10*mm;
    G4double DetOuterRadius = 11*mm;
    G4double DetThickness   = 28/2.*mm;

    G4Tubs   *Detector  = new G4Tubs("Detector", DetInnerRadius, DetOuterRadius, DetThickness, 0.*deg, 360*deg);
          Detector_log  = new G4LogicalVolume(Detector, DetMat, "Detector_log");
          Detector_phys = new G4PVPlacement(0, Pos3, Detector_log, "Detector_phys", World_log, 0, checkOverlaps);
 */           
        
    // ::::::::::::::::::::::::::::::::::::::
    // :::          CAD Geometries        :::
    // ::::::::::::::::::::::::::::::::::::::

    // In this section you can add more geometries using CAD files in .obj or .stl format.
    // *** Uncomment the following section if you want to add CAD files ***.
    // *** The "X" represents the number of CAD geometries you want to add and "Name" is the name of the CAD file ***.

    // How to proceed:
    //     1) Use the following command to import the geometry in either .obj or .stl format.
    //auto meshX = CADMesh::TessellatedMesh::FromOBJ("NAME.obj"); // If you want to add more CAD files, keep using mesh2,3,4, etc. Remember to write the correct file name.
    //auto mesh = CADMesh::TessellatedMesh::FromSTL("Name.stl");

    //     2) The next line will scale the geometry. Set it to 1 everytime
    //meshX->SetScale(1); // If you added more CAD files, use the same line, but with mesh2, mesh3, etc.

    //     3) The next line will set an offset in the position of the geometry. Modify it as needed and keep adding mesh2, mesh3, etc for more geometries.
    //meshX->SetOffset(x, y, z);
    //meshX->SetOffset(G4ThreeVector(x, y, z));

    //     4) Assign the names, and materials to your CAD geometries. Replace NAME for the name of your geometry (e.g NAME --> Shielding).
    //auto NAME = meshX->GetSolid(); // If you added more geometries, keep adding these lines of code for each geometry starting here up to...
    // ::: Name :::
    //auto NAME_log = new G4LogicalVolume(NAME, MATERIAL, "NAME_log",0,0,0);
    //new G4PVPlacement(rotation, Pos1, "NAME", NAME_log, World_phys, false, 0, false); // ...here.

    G4double x = 0.0; // Do not comment this line.
    G4double y = 0.0; // Do not comment this line.
    G4double z = 0.0; // Do not comment this line.
    
    //std::string basePath = "/Users/victor/Desktop/Gate/ADAPT/CAD_Files/Obj/";  // For .obj files
    std::string basePath = "/Users/victor/Desktop/Gate/ADAPT/CAD_Files/Stl/";  // For .stl files MUST BE IN ASCII STL

       
    // ::: Base :::
    //auto mesh1 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Base.obj");
    auto mesh1 = CADMesh::TessellatedMesh::FromSTL(basePath + "Base.stl");

    mesh1->SetScale(1);
    mesh1->SetOffset(x, y, z);
    mesh1->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto Base = mesh1->GetSolid();
    auto Base_log = new G4LogicalVolume(Base, PLA, "Base_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, Base_log, "Base", World_log, 0, checkOverlaps);
            
    // ::: Coupling1 :::
    //auto mesh2 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Coupling1.obj");
    auto mesh2 = CADMesh::TessellatedMesh::FromSTL(basePath + "Coupling1.stl");

    mesh2->SetScale(1);
    mesh2->SetOffset(x, y, z);
    mesh2->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto Coupling1 = mesh2->GetSolid();
    auto Coupling1_log = new G4LogicalVolume(Coupling1, PLA, "Coupling1_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, Coupling1_log, "Coupling1", World_log, 0, checkOverlaps);
            
    // ::: Coupling2 :::
    //auto mesh3 = CADMesh::TessellatedMesh::FromOBJ(basePath + "Coupling2.obj");
    auto mesh3 = CADMesh::TessellatedMesh::FromSTL(basePath + "Coupling2.stl");

    mesh3->SetScale(1);
    mesh3->SetOffset(x, y, z);
    mesh3->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto Coupling2 = mesh3->GetSolid();
    auto Coupling2_log = new G4LogicalVolume(Coupling2, PLA, "Coupling2_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, Coupling2_log, "Coupling2", World_log, 0, checkOverlaps);
            
    // ::: ExtShell :::
    //auto mesh4 = CADMesh::TessellatedMesh::FromOBJ(basePath + "ExtShell.obj");
    auto mesh4 = CADMesh::TessellatedMesh::FromSTL(basePath + "ExtShell.stl");

    mesh4->SetScale(1);
    mesh4->SetOffset(x, y, z);
    mesh4->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto ExtShell = mesh4->GetSolid();
    auto ExtShell_log = new G4LogicalVolume(ExtShell, PLA, "ExtShell_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, ExtShell_log, "ExtShell", World_log, 0, checkOverlaps);
            
    // ::: GlassVial :::
    //auto mesh5 = CADMesh::TessellatedMesh::FromOBJ(basePath + "GlassVial.obj");
    auto mesh5 = CADMesh::TessellatedMesh::FromSTL(basePath + "GlassVial.stl");

    mesh5->SetScale(1);
    mesh5->SetOffset(x, y, z);
    mesh5->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto GlassVial = mesh5->GetSolid();
    auto GlassVial_log = new G4LogicalVolume(GlassVial, Glass, "GlassVial_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1,GlassVial_log, "GlassVial", World_log, 0, checkOverlaps);
            
    // ::: IntShell :::
    //auto mesh6 = CADMesh::TessellatedMesh::FromOBJ(basePath + "IntShell.obj");
    auto mesh6 = CADMesh::TessellatedMesh::FromSTL(basePath + "IntShell.stl");

    mesh6->SetScale(1);
    mesh6->SetOffset(x, y, z);
    mesh6->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto IntShell = mesh6->GetSolid();
    auto IntShell_log = new G4LogicalVolume(IntShell, PLA, "IntShell_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, IntShell_log, "IntShell", World_log, 0, checkOverlaps);
            
    // ::: OF1 :::
    //auto mesh7 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OF1.obj");
    auto mesh7 = CADMesh::TessellatedMesh::FromSTL(basePath + "OF1.stl");

    mesh7->SetScale(1);
    mesh7->SetOffset(x, y, z);
    mesh7->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto OF1 = mesh7->GetSolid();
    auto OF1_log = new G4LogicalVolume(OF1, PMMA, "OF1_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, OF1_log, "OF1", World_log, 0, checkOverlaps); 
            
    // ::: OF2 :::
    //auto mesh8 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OF2.obj");
    auto mesh8 = CADMesh::TessellatedMesh::FromSTL(basePath + "OF2.stl");

    mesh8->SetScale(1);
    mesh8->SetOffset(x, y, z);
    mesh8->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto OF2 = mesh8->GetSolid();
    auto OF2_log = new G4LogicalVolume(OF2, PMMA, "OF2_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, OF2_log, "OF2", World_log, 0, checkOverlaps);
            
    // ::: OFJacket1 :::
    //auto mesh9 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OFJacket1.obj");
    auto mesh9 = CADMesh::TessellatedMesh::FromSTL(basePath + "OFJacket1.stl");

    mesh9->SetScale(1);
    mesh9->SetOffset(x, y, z);
    mesh9->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto OFJacket1 = mesh9->GetSolid();
    auto OFJacket1_log = new G4LogicalVolume(OFJacket1, PVC, "OFJacket1_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, OFJacket1_log, "OFJacket1", World_log, 0, checkOverlaps); // ...here.
            
    // ::: OFJacket2 :::
    //auto mesh10 = CADMesh::TessellatedMesh::FromOBJ(basePath + "OFJacket2.obj");
    auto mesh10 = CADMesh::TessellatedMesh::FromSTL(basePath + "OFJacket2.stl");

    mesh10->SetScale(1);
    mesh10->SetOffset(x, y, z);
    mesh10->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto OFJacket2 = mesh10->GetSolid();
    auto OFJacket2_log = new G4LogicalVolume(OFJacket2, PVC, "OFJacket2_log", 0, 0, 0);
                        new G4PVPlacement(Rotation, Pos1, OFJacket2_log, "OFJacket2",  World_log, 0, checkOverlaps); // ...here.
            
    // ::: SF :::
    //auto mesh11 = CADMesh::TessellatedMesh::FromOBJ(basePath + "SF.obj");
    auto mesh11 = CADMesh::TessellatedMesh::FromSTL(basePath + "SF.stl");

    mesh11->SetScale(1);
    mesh11->SetOffset(x, y, z);
    mesh11->SetOffset(G4ThreeVector(x, y, z));

    Rotation = new G4RotationMatrix();
    Rotation->rotateX(0.*deg);
    Rotation->rotateY(0.*deg);
    Rotation->rotateZ(0.*deg);

    auto DetectorStl     = mesh11->GetSolid();
    Detector_log = new G4LogicalVolume(DetectorStl, DetMat, "Detector_log", 0, 0, 0);
    Detector_phys = new G4PVPlacement(Rotation, Pos1, Detector_log, "Detector", World_log, 0, checkOverlaps); 
            




    
    // ::::::::::::::::::::::::::::::::::::::
    // :::    Visualisation Attributes    :::
    // ::::::::::::::::::::::::::::::::::::::

    // ::: Detector :::
    G4VisAttributes *DetVisAtt = new G4VisAttributes(G4Color(1.0, 1.0, 1.0, 0.8)); // Blue
    DetVisAtt->SetForceSolid(true);
    Detector_log->SetVisAttributes(DetVisAtt);
    OF1_log->SetVisAttributes(DetVisAtt);
    OF2_log->SetVisAttributes(DetVisAtt);
    GlassVial_log->SetVisAttributes(DetVisAtt);

    // ::: Source :::
    G4VisAttributes *SrcVisAtt = new G4VisAttributes(G4Color(1.0, 0.0, 0.0, 0.8)); // Red
    SrcVisAtt->SetForceSolid(true);
    Source_log->SetVisAttributes(SrcVisAtt);

    // ::: PLA :::
    G4VisAttributes *PLAVisAtt = new G4VisAttributes(G4Color(0.5, 0.5, 0.5, 0.8)); // Red
    PLAVisAtt->SetForceSolid(true);
    Base_log->SetVisAttributes(PLAVisAtt);
    ExtShell_log->SetVisAttributes(PLAVisAtt);
    IntShell_log->SetVisAttributes(PLAVisAtt);
    OFJacket1_log->SetVisAttributes(PLAVisAtt);
    OFJacket2_log->SetVisAttributes(PLAVisAtt);
    Coupling1_log->SetVisAttributes(PLAVisAtt);
    Coupling2_log->SetVisAttributes(PLAVisAtt);




    return World_phys;  // Always return the physical World
}


// ::::::::::::::::::::::::::::::::::
// :::    Sensitive Detector      :::
// :::         function           :::
// ::::::::::::::::::::::::::::::::::

void DetectorConstruction::ConstructSDandField()
{
    SensitiveDetector *sensDet = new SensitiveDetector("SensitiveDetector");
    Detector_log->SetSensitiveDetector(sensDet);
    G4SDManager::GetSDMpointer()->AddNewDetector(sensDet);
}

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::: End ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        